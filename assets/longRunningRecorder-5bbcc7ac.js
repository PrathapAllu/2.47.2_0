import{bl as M,x as g,bB as D,dI as ne,du as ae,dJ as ce,w as h,s as B,v as ie}from"./store-fcbe2a1f.js";import{v as q}from"./v4-c70744d4.js";const K="RejectedLongSummariesDB",V=1,T="rejectedLongSummaries",J=()=>new Promise((r,s)=>{const e=indexedDB.open(K,V);e.onupgradeneeded=o=>{const c=o.target.result;c.objectStoreNames.contains(T)||c.createObjectStore(T,{keyPath:"long_summary"})},e.onsuccess=o=>{r(o.target.result)},e.onerror=o=>{const{error:c}=o.target;g(c,{tags:{component:"rejectedLongSummariesDB",operation:"openDB"},extra:{dbName:K,dbVersion:V}}),s(c)}}),le=async r=>{if(r)try{const s=await J(),e=s.transaction([T],"readwrite");return e.objectStore(T).put({id:q(),long_summary:r,created_at:Date.now()}),await new Promise((o,c)=>{e.oncomplete=()=>{s.close(),M({message:"rejected_long_summary_stored",category:"rejectedLongSummariesDB",level:"info",data:{longSummaryLength:r.length}}),o()},e.onerror=a=>{const{error:i}=a.target;g(i,{tags:{component:"rejectedLongSummariesDB",operation:"storeRejectedLongSummary"},extra:{longSummaryLength:r.length}}),c(i)}})}catch(s){throw g(s,{tags:{component:"rejectedLongSummariesDB",operation:"storeRejectedLongSummary"},extra:{message:"[RejectedLongSummariesDB] Error storing long summary"}}),s}},de=async()=>{try{const r=(await J()).transaction([T],"readonly").objectStore(T);return await new Promise((s,e)=>{const o=r.getAllKeys();o.onsuccess=()=>{const c=o.result;M({message:"rejected_long_summaries_fetched",category:"rejectedLongSummariesDB",level:"info",data:{count:c.length}}),s(c)},o.onerror=c=>{const{error:a}=c.target;g(a,{tags:{component:"rejectedLongSummariesDB",operation:"getAllRejectedLongSummaries"}}),e(a)}})}catch(r){throw g(r,{tags:{component:"rejectedLongSummariesDB",operation:"getAllRejectedLongSummaries"},extra:{message:"[RejectedLongSummariesDB] Error fetching long summaries"}}),r}},ge="SuggestedScribesDB",ue=1,y="suggestedScribes",L=()=>new Promise((r,s)=>{const e=indexedDB.open(ge,ue);e.onupgradeneeded=o=>{const c=o.target.result;if(!c.objectStoreNames.contains(y)){const a=c.createObjectStore(y,{keyPath:"id"});a.createIndex("status","status",{unique:!1}),a.createIndex("created_at","created_at",{unique:!1}),a.createIndex("source_actions","source_actions",{unique:!1,multiEntry:!0})}},e.onsuccess=o=>{const c=o.target.result;r(c)},e.onerror=o=>{const c=`Failed to open SuggestedScribesDB: ${o.target.error}`;D("suggested_scribes_db_open_error",{error:c}),s(new Error(c))}}),Y=async r=>{try{console.log("[Suggested Scribes] Attempting to store suggestion:",r);const s=await L(),e=s.transaction([y],"readwrite"),o=e.objectStore(y),c={...r,id:q(),created_at:Date.now(),status:"pending"};return console.log("[Suggested Scribes] Created complete scribe:",c),await new Promise((a,i)=>{let n=null;const t=o.add(c);t.onsuccess=()=>{n=c.id,console.log("[Suggested Scribes] add() succeeded for",n)},t.onerror=d=>{const l=`Failed to store suggested Scribe: ${d.target.error}`;console.error("[Suggested Scribes] Store error:",l),D("suggested_scribes_db_store_error",{error:l}),i(new Error(l))},e.oncomplete=()=>{console.log("[Suggested Scribes] Transaction committed for scribe:",n),s.close(),n?a(n):i(new Error("Transaction completed but scribe ID missing"))},e.onerror=d=>{const l=`Transaction error while storing suggested Scribe: ${d.target.error}`;console.error("[Suggested Scribes] Transaction error:",l),D("suggested_scribes_db_transaction_error",{error:l}),i(new Error(l))}})}catch(s){throw console.error("[Suggested Scribes] Error storing suggested Scribe:",s),s}},Z=async r=>{try{const s=await L(),e=s.transaction([y],"readonly").objectStore(y),o=await new Promise((l,u)=>{const p=e.get(r);p.onsuccess=()=>l(p.result),p.onerror=m=>{const S=`Failed to get suggested Scribe: ${m.target.error}`;D("suggested_scribes_db_get_error",{error:S}),u(new Error(S))}});if(!o){console.warn(`[Suggested Scribes] Scribe not found for deletion: ${r}`);return}const c=await new Promise((l,u)=>{const p=indexedDB.open(_,E);p.onsuccess=()=>l(p.result),p.onerror=()=>u(p.error)}),a=o.source_actions,i=c.transaction([f],"readwrite"),n=i.objectStore(f);await Promise.all(a.map(l=>new Promise((u,p)=>{const m=n.delete(l);m.onsuccess=()=>{console.log(`[Suggested Scribes] Deleted associated action: ${l}`),u()},m.onerror=S=>{console.warn(`[Suggested Scribes] Failed to delete action ${l}:`,S.target.error),u()}}))),i.oncomplete=()=>{c.close()};const t=s.transaction([y],"readwrite"),d=t.objectStore(y);await new Promise((l,u)=>{const p=d.delete(r);p.onsuccess=()=>{console.log("[Suggested Scribes] Successfully deleted Scribe:",r),l()},p.onerror=m=>{const S=`Failed to delete suggested Scribe: ${m.target.error}`;D("suggested_scribes_db_delete_error",{error:S}),u(new Error(S))},t.oncomplete=()=>{s.close()}})}catch(s){throw console.error("[Suggested Scribes] Error deleting suggested Scribe:",s),s}},me=async(r,s,e)=>{try{if(console.log(`[Suggested Scribes] ${s==="accepted"?"Accepting":"Rejecting"} Scribe:`,r,e?`(with ${e.length} filtered actions)`:""),s==="rejected"){try{const u=await L(),p=u.transaction([y],"readonly").objectStore(y),m=await new Promise((S,x)=>{const I=p.get(r);I.onsuccess=()=>S(I.result),I.onerror=w=>x(w.target.error)});m!=null&&m.long_summary&&await le(m.long_summary),u.close()}catch(u){console.warn("[Suggested Scribes] Unable to persist rejected long_summary:",u)}await Z(r);return}if(!e||e.length===0){await Z(r);return}const o=await L(),c=o.transaction([y],"readonly").objectStore(y);if(!await new Promise((u,p)=>{const m=c.get(r);m.onsuccess=()=>u(m.result),m.onerror=S=>{const x=`Failed to get suggested Scribe: ${S.target.error}`;D("suggested_scribes_db_get_error",{error:x}),p(new Error(x))}})){console.warn(`[Suggested Scribes] Scribe not found for deletion: ${r}`);return}const a=new Set(e),i=await new Promise((u,p)=>{const m=indexedDB.open(_,E);m.onsuccess=()=>u(m.result),m.onerror=()=>p(m.error)}),n=i.transaction([f],"readwrite"),t=n.objectStore(f);console.log(`[Suggested Scribes] Deleting ${e.length} filtered actions`),await Promise.all(e.map(u=>new Promise((p,m)=>{const S=t.delete(u);S.onsuccess=()=>{console.log(`[Suggested Scribes] Deleted filtered action: ${u}`),p()},S.onerror=x=>{console.warn(`[Suggested Scribes] Failed to delete action ${u}:`,x.target.error),p()}}))),n.oncomplete=()=>{i.close()};const d=o.transaction([y],"readwrite"),l=d.objectStore(y);await new Promise((u,p)=>{const m=l.delete(r);m.onsuccess=()=>{console.log(`[Suggested Scribes] Successfully deleted Scribe: ${r}`),u()},m.onerror=S=>{const x=`Failed to delete suggested Scribe: ${S.target.error}`;D("suggested_scribes_db_delete_error",{error:x}),p(new Error(x))},d.oncomplete=()=>{o.close()}})}catch(o){throw console.error("[Suggested Scribes] Error handling suggestion:",o),o}},pe=async r=>{try{const s=await L(),e=s.transaction([y],"readonly"),o=e.objectStore(y);return await new Promise((c,a)=>{let i;r?i=o.index("status").getAll(r):i=o.getAll(),i.onsuccess=()=>{const n=i.result;c(n)},i.onerror=n=>{const t=`Failed to get suggested Scribes: ${n.target.error}`;D("suggested_scribes_db_get_error",{error:t}),a(new Error(t))},e.oncomplete=()=>{s.close()}})}catch(s){throw console.error("[Suggested Scribes] Error getting suggested Scribes:",s),s}},be=async r=>{try{const s=await new Promise((a,i)=>{const n=indexedDB.open(_,E);n.onsuccess=()=>a(n.result),n.onerror=()=>i(n.error)}),e=s.transaction([f],"readonly"),o=e.objectStore(f),c=await Promise.all(r.map(a=>new Promise((i,n)=>{const t=o.get(a);t.onsuccess=()=>{if(!t.result){n(new Error(`Action not found: ${a}`));return}i(t.result)},t.onerror=()=>n(t.error)})));return e.oncomplete=()=>{s.close()},c}catch(s){throw console.error("[Suggested Scribes] Error copying screenshots:",s),s}},we=async()=>{try{console.log("[Suggested Scribes] Clearing all pending suggested scribes (preserving actions)");const r=await L(),s=r.transaction([y],"readwrite").objectStore(y).index("status"),e=await new Promise((o,c)=>{const a=s.getAll("pending");a.onsuccess=()=>o(a.result),a.onerror=i=>{const n=`Failed to get pending scribes: ${i.target.error}`;D("suggested_scribes_db_get_error",{error:n}),c(new Error(n))}});console.log(`[Suggested Scribes] Found ${e.length} pending scribes to clear`);for(const o of e)await new Promise((c,a)=>{const i=r.transaction([y],"readwrite"),n=i.objectStore(y).delete(o.id);n.onsuccess=()=>{console.log(`[Suggested Scribes] Deleted scribe: ${o.id} (kept actions intact)`),c()},n.onerror=t=>{const d=`Failed to delete suggested Scribe: ${t.target.error}`;D("suggested_scribes_db_delete_error",{error:d}),a(new Error(d))},i.oncomplete=()=>{c()}});r.close(),console.log(`[Suggested Scribes] Successfully cleared ${e.length} pending scribes (preserved all actions)`)}catch(r){throw console.error("[Suggested Scribes] Error clearing pending suggested scribes:",r),r}},F=(()=>({BASE_URL:"/",MODE:"production",DEV:!1,PROD:!0,SSR:!1}).VITE_CORTEX_BASE_URL?{}.VITE_CORTEX_BASE_URL:"https://cortex.scribehow.com")(),O=ne({baseURL:F,getAuthToken:async()=>ae(),setAuthToken:async r=>{await ce(r)}}),_="LongRunningRecorderDB",E=4,f="actions",b="tasks";async function X(){var r,s;h("feature","long-running-recorder"),h("operation","generate-persona");try{return((s=(r=await O.get(`${F}/api/v1/long_recorder/persona`))==null?void 0:r.data)==null?void 0:s.persona)||""}catch(e){return g(e,{extra:{context:"Failed to fetch persona from Cortex"}}),""}}async function Q(){h("feature","long-running-recorder"),h("operation","get-current-persona");try{const r=await new Promise(e=>{chrome.storage.local.get(["options"],o=>{e(o.options?JSON.parse(o.options):{})})});let s=r.longRunningRecorderPersona||"";if(!s&&(s=await X(),s)){const e={...r,longRunningRecorderPersona:s};chrome.storage.local.set({options:JSON.stringify(e)})}return s}catch(r){return g(r,{extra:{context:"Error getting persona from storage"}}),""}}const ye=15*60*1e3,H=6e4,W=15e3;function ee(){var r;try{const s=(r=ie(B.getState()))==null?void 0:r.lrr2025;if(s){let e;try{e=JSON.parse(s)}catch{e=void 0}const o=Number(e==null?void 0:e.polling_rate),c=Number(e==null?void 0:e.polling_variance_ms);return{pollingRate:Number.isInteger(o)&&o>0?o:H,pollingVarianceMs:Number.isInteger(c)&&c>=0?c:W}}}catch{}return{pollingRate:H,pollingVarianceMs:W}}function R(r=!1){return h("feature","long-running-recorder"),h("operation","open-database"),new Promise((s,e)=>{const o=indexedDB.open(_,E);let c=!1;o.onerror=a=>{const{error:i}=a.target;g(i||new Error(`Unknown error opening ${_} v${E}`),{extra:{context:`Error opening ${_} database`}}),e(i||new Error(`Unknown error opening ${_} v${E}`))},o.onupgradeneeded=a=>{c=!0;const i=a.target.result,n=a.target.transaction;n&&(n.oncomplete=()=>{},n.onerror=t=>{g(t.target.error,{extra:{context:"Database upgrade transaction error"}})},n.onabort=t=>{g(t.target.error,{extra:{context:"Database upgrade transaction aborted"}})});try{i.objectStoreNames.contains(f)||i.createObjectStore(f,{keyPath:"id"}).createIndex("timestamp","timestamp")}catch(t){g(t,{extra:{context:`Error during ${f} creation`}})}try{i.objectStoreNames.contains(b)||i.createObjectStore(b,{keyPath:"id"}).createIndex("status","status")}catch(t){g(t,{extra:{context:`Error during ${b} creation`}})}},o.onsuccess=a=>{const i=a.target.result;if(!i.objectStoreNames.contains(b)){if(g(new Error(`${b} missing in DB v${E}`),{extra:{context:`${b} missing in database`}}),i.close(),!c&&!r){const n=indexedDB.deleteDatabase(_);n.onsuccess=()=>{R(!0).then(s).catch(e)},n.onerror=t=>{g(t.target.error,{extra:{context:`Failed to delete corrupt DB ${_}`}}),e(new Error(`Failed to delete corrupt DB ${_}. ${b} missing.`))},n.onblocked=t=>{g(t.target.error,{extra:{context:`Delete blocked for DB ${_} while trying to fix missing ${b}`}}),e(new Error(`Delete blocked for DB ${_} while trying to fix missing ${b}.`))}}else c&&!r?setTimeout(()=>R(!0).then(s).catch(e),100):(g(new Error(`${b} missing in DB v${E} after all attempts`),{extra:{context:`${b} still missing after all attempts`}}),e(new Error(`${b} missing in DB v${E} after all attempts.`)));return}s(i)},o.onblocked=a=>{g(a.target.error,{extra:{context:`DB open blocked for ${_} v${E}`}}),e(a.target.error||new Error(`DB open blocked for ${_} v${E}`))}})}const k={PENDING:"pending",RUNNING:"running",CANCELLED:"cancelled",COMPLETED:"completed",FAILED:"failed"};async function Se(r,s={}){h("feature","long-running-recorder"),h("operation","create-task-record");let e;try{if(e=await R(),!e.objectStoreNames.contains(b))throw g(new Error(`${b} object store not found when trying to create task`),{extra:{context:`${b} object store not found when trying to create task`}}),e&&e.close(),new Error(`${b} object store not found when trying to create task. This indicates an upgrade issue.`);const o=e.transaction([b],"readwrite"),c=o.objectStore(b),a=q(),i={id:a,type:r,status:k.PENDING,timestamp:Date.now(),metadata:s,result:null};return await new Promise((n,t)=>{o.oncomplete=()=>{e&&e.close(),n(a)},o.onerror=l=>{g(l.target.error,{extra:{context:`Transaction error for task ${a}`}}),e&&e.close(),t(l.target.error)},o.onabort=l=>{g(new Error("Transaction aborted"),{extra:{context:`Transaction aborted for task ${a}`}}),e&&e.close(),t(new Error("Transaction aborted"))};const d=c.add(i);d.onsuccess=()=>{},d.onerror=l=>{g(l.target.error,{extra:{context:`Failed to add task ${a} to store`}})}})}catch(o){throw g(o,{extra:{context:"Outer catch error in createTaskRecord"}}),e&&e.close(),o}}async function A(r,s,e=null){h("feature","long-running-recorder"),h("operation","update-task-record");const o=await R(),c=o.transaction([b],"readwrite"),a=c.objectStore(b);return new Promise((i,n)=>{const t=a.get(r);t.onsuccess=()=>{const d=t.result;if(!d){n(new Error(`Task not found: ${r}`));return}d.status=s,e!==null&&(d.result=e),d.completedAt=Date.now();const l=a.put(d);l.onsuccess=()=>{i()},l.onerror=u=>{g(u.target.error,{extra:{context:`Failed to update task ${r}`}}),n(u.target.error)}},t.onerror=d=>{g(d.target.error,{extra:{context:`Failed to get task ${r}`}}),n(d.target.error)},c.oncomplete=()=>{o.close()}})}async function re(r){h("feature","long-running-recorder"),h("operation","get-task-record");const s=await R(),e=s.transaction([b],"readonly"),o=e.objectStore(b);return new Promise((c,a)=>{const i=o.get(r);i.onsuccess=()=>{c(i.result)},i.onerror=n=>{g(n.target.error,{extra:{context:`Failed to get task ${r}`}}),a(n.target.error)},e.oncomplete=()=>{s.close()}})}async function G(){const r=await R(),s=r.transaction([b],"readonly").objectStore(b),e=await new Promise((o,c)=>{const a=s.getAll();a.onsuccess=()=>o(a.result),a.onerror=i=>c(i.target.error)});return r.close(),e.filter(o=>(o==null?void 0:o.type)==="analyze_actions"&&(o.status===k.PENDING||o.status===k.RUNNING))}const he={messageType:"ANALYZE_LONG_RUNNING_ACTIONS"},fe={messageType:"ANALYZE_LONG_RUNNING_ACTIONS_SUCCESS"},te={messageType:"ANALYZE_LONG_RUNNING_ACTIONS_ERROR"};async function _e(r){h("feature","long-running-recorder"),h("operation","process-and-store-suggestions");try{const s=await G();s.length&&await Promise.all(s.map(a=>A(a.id,k.CANCELLED,{reason:"superseded_by_new_task"})));const e=[typeof r=="string"?JSON.parse(r):r];if(!e.length)return;const o=60,c=e.filter(a=>!((a.confidence||0)<o));for(const a of c){const i=a.actions.map(d=>d),n={title:a.title,description:a.description||"No description available",long_summary:a.long_summary||"",actions:i,source_actions:i,confidence:a.confidence,time_span:a.time_span,domain:r==null?void 0:r.domain},t=await Y(n)}}catch(s){g(s,{extra:{context:"Error processing patterns"}})}}const xe=r=>{const s=[...r].sort((t,d)=>t.timestamp-d.timestamp);let e=null;const o=[],c=new Set,a=t=>["enter","return","tab","escape"].includes(t.toLowerCase()),i={space:" ",period:".",dot:".",comma:",",minus:"-",dash:"-",plus:"+",equals:"=",semicolon:";",colon:":",quote:"'",doublequote:'"',backslash:"\\",forwardslash:"/",slash:"/",underscore:"_",leftbracket:"[",rightbracket:"]",leftparen:"(",rightparen:")",leftbrace:"{",rightbrace:"}",lessthan:"<",greaterthan:">",questionmark:"?",exclamation:"!",at:"@",hash:"#",dollar:"$",percent:"%",caret:"^",ampersand:"&",asterisk:"*",tilde:"~",backtick:"`",pipe:"|"},n=(t,d=!1)=>!t||t.length===0?"":d||t.some(l=>a(l))?`Press ${t.join(" + ")}`:`Type "${t.map(l=>{const u=l.toLowerCase();return i[u]||l}).join("")}"`;return s.forEach(t=>{if(t.kind==="keyboard_action"){const d=Object.values(t.modifiers).filter(l=>l).length;if(d>1||d>0&&!t.modifiers.shiftKey||a(t.key)){e&&e.keys.length>0&&(e.description=n(e.keys),o.push(e),e=null);const l=[];t.modifiers.metaKey&&l.push("cmd"),t.modifiers.ctrlKey&&l.push("ctrl"),t.modifiers.altKey&&l.push("alt"),t.modifiers.shiftKey&&l.push("shift"),l.push(t.key),o.push({...t,kind:"keyboard_combination_action",keys:l,description:n(l,!0)}),c.add(t.id)}else e?t.target_selector===e.target_selector?(c.add(t.id),e.source_action_ids.push(t.id),["up","down","left","right"].includes(t.key)?(e.includesArrowKeys=!0,e.keys.push(t.key)):t.key.toLowerCase()==="backspace"&&!e.includesArrowKeys&&e.keys.length>0?e.keys.pop():e.keys.push(t.key),e.end_timestamp=t.timestamp,t.screenshot&&(e.screenshot=t.screenshot)):(e.keys.length>0&&(e.description=n(e.keys),o.push(e)),e={...t,kind:"keyboard_sequence_action",keys:[t.key],includesArrowKeys:!1,source_action_ids:[t.id],start_timestamp:t.timestamp,end_timestamp:t.timestamp},c.add(t.id)):(e={...t,kind:"keyboard_sequence_action",keys:[t.key],includesArrowKeys:!1,source_action_ids:[t.id],start_timestamp:t.timestamp,end_timestamp:t.timestamp},c.add(t.id))}else e&&e.keys.length>0&&(e.description=n(e.keys),o.push(e),e=null)}),e&&e.keys.length>0&&(e.description=n(e.keys),o.push(e)),{combinedActions:o,combinedActionIds:Array.from(c)}};async function ke(r){return O.get(`${F}/api/v1/long_recorder/poll/analyze/${r}`)}async function Ee(r,s,e){const o=async()=>{var c,a,i;if(((c=await re(r))==null?void 0:c.status)===k.CANCELLED){console.log(`[Analyze] Poll loop for ${r} aborted (task cancelled)`);return}try{const{data:n}=await ke(s);if(n.status==="processing"){await A(r,k.PENDING);const{pollingRate:t,pollingVarianceMs:d}=ee(),l=Math.floor(Math.random()*d);setTimeout(o,t+l)}else if(n.status==="queued"){const{pollingRate:t,pollingVarianceMs:d}=ee();console.log(`[Analyze] Async analysis job queued, polling again in ${t/1e3} second(s)`);const l=Math.floor(Math.random()*d);setTimeout(o,t+l)}else if(n.status==="completed"){const t=((a=n.result)==null?void 0:a.groups)||[];for(const d of t)await _e(d);try{chrome.runtime.sendMessage({messageType:"suggestedScribesUpdated"})}catch(d){console.warn("[Analyze] Unable to send suggestedScribesUpdated message",d)}await A(r,k.COMPLETED,{analysis:t,message:"Successfully analyzed and stored suggestions"}),B.dispatch({type:"suggestedScribesTask/completed"});return}else if(n.status==="failed"){console.error("[Analyze] Async analysis error:",n.error),await A(r,k.FAILED,{error:n.error}),B.dispatch({type:"suggestedScribesTask/failed",payload:{error:n.error}});return}}catch(n){console.error("[Analyze] Poll error:",n);const t=((i=n==null?void 0:n.response)==null?void 0:i.status)===404?"not_found":n.message;await A(r,k.FAILED,{error:t}),B.dispatch({type:"suggestedScribesTask/failed",payload:{error:t}});return}Date.now()-e>ye&&(console.error(`[Analyze] task ${r} timed-out after 15 minutes`),await A(r,k.FAILED,{error:"timeout"}),B.dispatch({type:"suggestedScribesTask/failed",payload:{error:"timeout"}}))};o()}async function $e(){var e,o,c,a;h("feature","long-running-recorder"),h("operation","analyze-long-running-actions");let r,s;try{try{await new Promise(w=>{chrome.runtime.sendMessage({messageType:"flushEnhancements"},()=>w())})}catch(w){g(w,{extra:{context:"Analyze flushEnhancements failed"}})}const i=await G();i.length&&await Promise.all(i.map(w=>A(w.id,k.CANCELLED,{reason:"superseded_by_new_task"}))),r=await Se("analyze_actions",{startTime:Date.now()}),s=await R();const n=s.transaction([f],"readwrite").objectStore(f),t=await new Promise((w,N)=>{const $=n.getAll();$.onsuccess=()=>w($.result),$.onerror=P=>{g(P.target.error,{extra:{context:"Error getting actions from store"}}),N(P.target.error)}}),{combinedActions:d,combinedActionIds:l}=xe(t);await new Promise((w,N)=>{const $=s.transaction([f],"readwrite"),P=$.objectStore(f);$.oncomplete=()=>{w()},$.onerror=j=>{g(j.target.error,{extra:{context:"Actions delete/add transaction error"}}),N(j.target.error)};const oe=l.map(j=>new Promise((v,z)=>{const C=P.delete(j);C.onsuccess=()=>v(),C.onerror=U=>z(U.target.error)})),se=d.filter(j=>j.kind==="keyboard_sequence_action"||j.kind==="keyboard_combination_action").map(j=>new Promise((v,z)=>{const C=P.add(j);C.onsuccess=()=>v(),C.onerror=U=>z(U.target.error)}));Promise.all([...oe,...se]).catch(N)});const u=s.transaction([f],"readonly").objectStore(f),p=(await new Promise((w,N)=>{const $=u.getAll();$.onsuccess=()=>w($.result),$.onerror=P=>{g(P.target.error,{extra:{context:"Error getting final actions from store"}}),N(P.target.error)}})).map(({screenshot:w,...N})=>N);let m="";try{m=await Q()}catch(w){g(w,{extra:{context:"Error getting persona"}})}let S=[];try{S=await de()}catch(w){g(w,{extra:{context:"Error fetching rejected long summaries"}})}const x=(o=(e=await O.post(`${F}/api/v1/long_recorder/actions/analyze`,{persona:m,actions:p,rejected_long_summaries:S}))==null?void 0:e.data)==null?void 0:o.session_id;if(!x)throw new Error("Missing session_id from Cortex analyze response");await A(r,k.PENDING,{message:"Queued for analysis",server_session_id:x});try{B.dispatch({type:"suggestedScribesTask/started",payload:{taskId:r}})}catch(w){g(w,{extra:{context:"Error dispatching async-processing redux update"}})}const I=Date.now();return Ee(r,x,I),{...fe,payload:{message:"Analysis job queued",taskId:r}}}catch(i){g(i,{extra:{context:"Error analyzing actions"}});const n=((a=(c=i.response)==null?void 0:c.data)==null?void 0:a.message)||i.message||"Failed to analyze actions";return r&&await A(r,k.FAILED,{error:n}),{...te,payload:n,taskId:r}}finally{s&&s.close()}}async function De(){const r=await G();return r.length?r[0].id:null}export{f as A,F as C,_ as D,E as a,Q as b,O as c,he as d,te as e,we as f,pe as g,$e as h,be as i,re as j,De as k,X as l,L as o,Y as s,me as u};
